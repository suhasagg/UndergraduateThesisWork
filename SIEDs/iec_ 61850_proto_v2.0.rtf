{\rtf1\ansi\ansicpg1252\uc1\deff0\stshfdbch0\stshfloch0\stshfhich0\stshfbi0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f37\froman\fcharset238\fprq2 Times New Roman CE;}{\f38\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f40\froman\fcharset161\fprq2 Times New Roman Greek;}{\f41\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f42\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f43\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f44\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f45\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}
{\f47\fswiss\fcharset238\fprq2 Arial CE;}{\f48\fswiss\fcharset204\fprq2 Arial Cyr;}{\f50\fswiss\fcharset161\fprq2 Arial Greek;}{\f51\fswiss\fcharset162\fprq2 Arial Tur;}{\f52\fswiss\fcharset177\fprq2 Arial (Hebrew);}
{\f53\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f54\fswiss\fcharset186\fprq2 Arial Baltic;}{\f55\fswiss\fcharset163\fprq2 Arial (Vietnamese);}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;
\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;
\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\*\cs10 \additive \ssemihidden Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1024\langfe1024\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}}{\*\latentstyles\lsdstimax156\lsdlockeddef0}{\*\rsidtbl \rsid131146\rsid1339252
\rsid3675463\rsid4483007\rsid5309863\rsid5326569\rsid6228610\rsid10033588}{\*\generator Microsoft Word 11.0.6568;}{\info{\author suhas}{\operator suhas}{\creatim\yr2007\mo12\dy9\hr19\min31}{\revtim\yr2007\mo12\dy28\hr7\min34}{\version9}{\edmins25}
{\nofpages5}{\nofwords1644}{\nofchars9376}{\*\company IIT}{\nofcharsws10999}{\vern24579}}\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0
\dgvshow3\jcompress\viewkind4\viewscale100\nolnhtadjtbl\rsidroot5326569 \fet0\sectd \linex0\sectdefaultcl\sftnbj {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3
\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}
{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain 
\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1\fs20\insrsid4483007                                                                                                         }{
\f1\fs20\insrsid5326569 I}{\f1\fs20\insrsid4483007 EC 61850 prototype v2.0}{\f1\fs20\insrsid6228610           }{\f1\fs20\insrsid4483007 
\par }{\f1\fs20\insrsid6228610                                                                                            \'a9 Suhas Aggarwal (suhas@iitg.ernet.in)
\par }\pard \ql \fi-360\li360\ri0\nowidctlpar\faauto\rin0\lin360\itap0\pararsid6228610 {\f1\fs20\insrsid4483007                                                                   }{\f1\fs20\insrsid5326569                              }{\f1\fs20\insrsid4483007 
( focus on database design }{\f1\fs20\insrsid5326569 aspects ) }{\f1\fs20\insrsid4483007 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f1\fs20\insrsid4483007  
\par Information Model Database design-
\par 
\par }{\f1\fs20\insrsid6228610 struct}{\f1\fs20\insrsid4483007  server
\par \{
\par *logical_device[20];
\par \}
\par 
\par struct logical_device
\par \{
\par *logical_node[20];
\par \}
\par 
\par struct logical_node
\par \{
\par *data[20];
\par \}
\par 
\par struct data
\par \{
\par *data_attribute[20];
\par \}
\par 
\par Allocate memory to server record dynamically =>malloc
\par 
\par memory allocated to 20 logical device pointers (total 80 bytes ,4 bytes for each pointer)
\par 
\par As logical devices are being initialised 
\par 
\par Allocate memory to logical device records =>malloc
\par (memory allocated to entire logical device record)
\par 
\par memory allocat}{\f1\fs20\insrsid5326569 ed to 20 logical node pointers }{\f1\fs20\insrsid4483007 (total 80 bytes,4 bytes for each pointer)
\par   
\par As logical nodes }{\f1\fs20\insrsid5326569 are being intialis}{\f1\fs20\insrsid4483007 ed 
\par 
\par Allocate memory to logical node records=>malloc
\par (memory allocated to entire logical node record)
\par 
\par memory allocated to 20 data pointers (total 80 bytes,4 bytes for each pointer)
\par 
\par As data is being intialised
\par 
\par Allocate memory to data records=>malloc
\par (memory allocated to entire data record)
\par 
\par memory allocated to 20 data attribute pointers (total 80 bytes,4 bytes for each pointer)
\par 
\par Finally as da}{\f1\fs20\insrsid5326569 ta attributes are being intializ}{\f1\fs20\insrsid4483007 ed, allocate memory to data attribute records within a data using malloc.
\par Involves memory allocation to fields namely name(string type),functional constraint (string type),}{\f1\fs20\insrsid5326569  }{\f1\fs20\insrsid4483007 trigger option}{\f1\fs20\insrsid5326569  }{\f1\fs20\insrsid4483007 
(string type),value (depending on type field ,int,float,string or composite type like analogue value (memory allocated accordingly)
\par 
\par Design feature-
\par 
\par Memory is allocated to each and every individual record as it is being created .
\par For }{\f1\fs20\insrsid5326569 e.g -}{\f1\fs20\insrsid4483007  during }{\f1\fs20\insrsid5326569 initialization}{\f1\fs20\insrsid4483007  of server, memory is allocated to 20 logical device pointers (needing only 32 bits to store the address) not records.

\par Later when individual logical device records are }{\f1\fs20\insrsid5326569 initialized, memory}{\f1\fs20\insrsid4483007  is allocated to entire logical device record containing 20 logical node pointers,}{\f1\fs20\insrsid5326569  }{\f1\fs20\insrsid4483007 
this trend goes down the hierarchy.
\par 
\par 
\par Record indexing and accessing times-
\par 
\par In order to access a logical device record within the server ( 2 address reads are required one for reading the address of pointer to 
server object to find address of server record and one for reading address which contains server record which contain 20 pointers to logical device records.
\par 
\par Specify logical device no. (this no. serves as a key for accessing the record )  
\par Get address of pointer to logical device record O(1) (pointer address calculated directly =>}{\f1\fs20\insrsid5326569 
\par }{\f1\fs20\insrsid4483007  array}{\f1\fs20\insrsid5326569  }{\f1\fs20\insrsid4483007 [logical device no.]
\par Retrieve the logical device record via pointer (2 address reads are required ,one corresponding to address of pointer and one corresponding to address of record present in the pointer)  
\par }{\f1\fs20\insrsid5326569 total over}{\f1\fs20\insrsid4483007 
head is summation of all the overheads mentioned above (2 address reads corresponding to server object + calculation of address of appropriate pointer + 2 address reads,  one corresponding to address of pointer
 and one corresponding to address of record present in the pointer)
\par 
\par To access logical node record
\par Specify logical node no. 
\par Get address of pointer to logical node record present within logical device record (total overhead =>above calculated overhead + O(1) (pointer address calculated directly => array}{\f1\fs20\insrsid5326569  }{\f1\fs20\insrsid4483007 [logical node no.]))

\par Retrieve the logical node record via pointer (2 address reads are required ,one corresponding to address of pointer and one corresponding to address of record present in the pointer)  
\par }{\f1\fs20\insrsid5326569 total over}{\f1\fs20\insrsid4483007 head is summation of all the overheads mentioned above .
\par 
\par To access data record
\par Specify data no.
\par Get address of pointer to data record present within logical node record (total overhead =>above calculated overhead + O(1) (pointer address calculated directly => array}{\f1\fs20\insrsid5326569  }{\f1\fs20\insrsid4483007 [data no.]))
\par Retrieve the data record via pointer (2 address reads are required ,one corresponding to address of pointer and one corresponding to address of record present in the pointer)  
\par }{\f1\fs20\insrsid5326569 total over}{\f1\fs20\insrsid4483007 head is summation of all the overheads mentioned above .
\par 
\par Finally to access various data attribute records present within the data.
\par Specify data attribute no. 
\par Get address of pointer to data attribute record present within data record (total overhead =>above calculated overhead + O(1) (pointer address calculated directly => array[data attribute no.]))
\par Retrieve the data attribute record via pointe}{\f1\fs20\insrsid5326569 r (2 address reads are required}{\f1\fs20\insrsid4483007 ,one corresponding to address of pointer and one corresponding to address of record present in the pointer,}{
\f1\fs20\insrsid5326569  }{\f1\fs20\insrsid4483007 within the record, further pointers to various fields of data attributes will be present,}{\f1\fs20\insrsid5326569  }{\f1\fs20\insrsid4483007 2 address reads will be required,}{\f1\fs20\insrsid5326569  }{
\f1\fs20\insrsid4483007 one for reading the address of pointer and one for reading the field value whose address is contained in the pointer)
\par 
\par Alternate record indexing.
\par 
\par Use of dynamic hashing.
\par 
\par This is a slight variant of linear hashing.
\par 
\par It may be useful for indexing the records at data and data attribute level where one may wish to access these records by specifying the individual data names and data attribute names.
\par 
\par data name or data attribute name=>Unique number encoding.
\par Hash(unique number encoding)=Appropriate bucket no.
\par 
\par A sample set up -
\par 
\par Initially hash table will contain 4 buckets.
\par Bucket capacity =2
\par 
\par A sample set up
\par 
\par Bucket0  - data01 -02
\par     ||
\par Bucket1  - 11 -12 
\par     ||
\par Bucket2  - data21 - data22
\par     ||
\par Bucket3  - 31 -32 
\par 
\par Suppose an entry is to be inserted in bucket2 further which is full,linear hashing will split bucket0 first and redistribute the entries within bucket 00 and bucket 10 on add}{\f1\fs20\insrsid3675463 i}{\f1\fs20\insrsid4483007 
tion of first overflow page in bucket2.
\par On further addition of data entry in bucket 2,a second overflow page will be added (on assumption a page will contain a single data entry) .
\par This will result in splitting of bucket 1 into bucket 01 and bucket 11 ,each of capacity 2.
\par Finally on addition of a data entry further to bucket 2 ,bucket 2 will be split and entries of bucket will be redistributed accordingly.
\par 
\par I plan to split the bucket at the moment it has the tendency to overflow.
\par Buckets won't be split in the order 0th ,Ist and 2nd.
\par As bucket 2 is about to overflow first,it will be split right at that moment without the addition of any overflow pages.
\par This will require creation of buckets 10 and bucket 11 as well.
\par But using above design feature, we can create just create pointer to bucket 10 and bucket 11 rather than creating a bucket record having a capacity of 2 data entries.
\par Now as bucket 12 is to be filled ,we can allocate memory to structure of bucket 12 having the space of 2 data entries.
\par This will save unnecessary memory allocation and redistribution of values during record insertions.
\par When bucket 0 or 1 is about to overflow ,as it split pointers are already present ,we can simply allocate memory to the pointer to split bucket structures and redistribute the entries.
\par 
\par 
\par struct hash_table
\par  \{
\par   vector *bucket[4];
\par  \}
\par 
\par struct bucket
\par \{
\par *key;
\par *data[2];
\par \}
\par 
\par One possible implementation can be by using vector of buckets which grows dynamically using pushback( ) function.
\par In the above case pushback will be called 3 times.
\par 3 pointer to bucket structures will be appended at the end of existing bucket vector.  
\par 
\par Database type-
\par 
\par A real time memory resident database.
\par Database should reside in main memory all the times to save the disk latencies involved while fetching the data from the disk. 
\par 
\par 
\par Memory Allocation of records.
\par 
\par Refinement of memory allocation interface - Use of TLSF dynamic memory allocator especially suited for real time systems.
\par Comparison with other memory allocation algorithms-
\par 
\par                                  Allocation          Deallocation
\par 
\par First fit/Best fit          O(M/(2.N))            O(1)    
\par Binary buddy            O(log(M/N))         O(log(M/N))
\par DL malloc                 O(M/N)                 O(1) 
\par AVL                         O(2.44.log(M/N)   O(4.32.log(M/N)
\par Half fit/TLSF              O(1)                     O(1)
\par 
\par Base of logarithms is 2
\par 
\par M =Maximum memory size (Heap)
\par N  =Largest allocated block
\par 
\par 
\par Backup scheme for the database and fast crash recovery.
\par 
\par Division of information into categories
\par 
\par 1)Temporal
\par 2)Persistent
\par 
\par Temporal region will consist of information which is frequently updated or changed such as data or data attribute records.
\par Persistent region will consist of information which is almos}{\f1\fs20\insrsid3675463 t static such as logical device}{\f1\fs20\insrsid4483007 ,logical node records.
\par 
\par Creating checkpoints to take efficient back up of data.
\par 
\par Temporal region =>checkpoint frequency very high.
\par 
\par Persistent region=>checkpoint frequency low.
\par 
\par At checkpoints database image present in memory is copied to the disk.
\par 
\par }{\f1\fs20\insrsid6228610 
\par }{\f1\fs20\insrsid4483007 Data and data attribute records are changed pretty frequently so they are backed up at a much higher rate than persistent data such as logical node and device information. 
\par 
\par Incase of a crash ,database image corresponding to the latest checkpoint is loaded in the memory.
\par 
\par Reload threshold =>When certain segments of database image is loaded in memory, database can start operating and processing transactions or service commands.
\par This feature enables fast recovery. 
\par 
\par Transaction processing.
\par 
\par IEC 61850 server- a multi-client server . 
\par 
\par Assignment of priority to transactions.
\par Server maintains a priority queue per client for processing transactions.
\par Priority can be set on the basis of transaction deadlines.
\par Also a queue can be maintained for transactions demanding operation on same data when issued by multiple clients .Assign priority = criteria can be transaction deadlines.
\par This also require including a time stamp field in request and response data units of service interface.
\par       
\par Also locking of data pages should be enabled.
\par Say for eg- a client has issued the command setdatavalues (page whose contents are being edited should be locked ,so that concurrent commands issued by other clients such as getdatavalues from that page should be blocked ti
ll the transaction is met ,this will save retrieval of improper datavalues ( say from partially written or changed page)
\par Also, condition checks operating on data should be paused while data setting is in process.
\par 
\par Security of database.
\par 
\par Maintainence of access control lists.
\par Implementation of views (access control feature present in IEC 61850)
\par Based on authentication parameters clients pass while setting up a connection with the server they are granted}{\f1\fs20\insrsid5309863  a certain view of the database}{\f1\fs20\insrsid4483007 (visibility level of data present and set of services )
\par A server may have implementation of certain no.of views.
\par 
\par Databases used within the internal substation network (control network) should make use of real time memory resident feature described in the above database model .For eg.-policies, multicast address table and other records present in security hub .

\par This will save the latencies involved in fetching the data from the disk.  
\par 
\par Future work-
\par Designing e}{\f1\fs20\insrsid1339252 xperiments to measure latencies related to application layer.}{\f1\fs20\insrsid4483007 
\par 
\par }}